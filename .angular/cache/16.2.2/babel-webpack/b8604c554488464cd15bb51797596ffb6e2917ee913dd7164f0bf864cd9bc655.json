{"ast":null,"code":"import _asyncToGenerator from \"/Users/chris/workspace/background-geolocation/cordova/SampleApp/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport BackgroundGeolocation from \"../cordova-background-geolocation\";\nimport { environment } from \"../../environments/environment\";\nimport { ICON_MAP } from \"../lib/icon-map\";\nimport { COLORS } from \"../lib/colors\";\nimport { LongPress } from \"./lib/LongPress\";\nimport { registerTransistorAuthorizationListener } from \"../lib/authorization\";\nimport { SettingsPage } from './modals/settings/settings.page';\nimport { GeofencePage } from \"./modals/geofence/geofence.page\";\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@ionic/angular\";\nimport * as i2 from \"@angular/router\";\nimport * as i3 from \"./lib/BGService\";\nimport * as i4 from \"./lib/SettingsService\";\nimport * as i5 from \"@angular/common\";\nimport * as i6 from \"@angular/forms\";\nconst _c0 = [\"map\"];\nconst _c1 = function (a0, a1) {\n  return {\n    \"border-left\": a0,\n    \"border-right\": a1\n  };\n};\nconst CONTAINER_BORDER_POWER_SAVE_OFF = 'none';\nconst CONTAINER_BORDER_POWER_SAVE_ON = '7px solid red';\nconst LocalStorage = window.localStorage;\n// Messages\nconst MESSAGE = {\n  reset_odometer_success: 'Reset odometer success',\n  reset_odometer_failure: 'Failed to reset odometer: {result}',\n  sync_success: 'Sync success ({result} records)',\n  sync_failure: 'Sync error: {result}',\n  destroy_locations_success: 'Destroy locations success ({result} records)',\n  destroy_locations_failure: 'Destroy locations error: {result}',\n  removing_markers: 'Removing markers...',\n  rendering_markers: 'Rendering markers...'\n};\nlet AdvancedPage = /*#__PURE__*/(() => {\n  var _class;\n  class AdvancedPage {\n    constructor(navCtrl, alertCtrl, router, modalController, loadingCtrl, bgService, settingsService, zone, platform) {\n      this.navCtrl = navCtrl;\n      this.alertCtrl = alertCtrl;\n      this.router = router;\n      this.modalController = modalController;\n      this.loadingCtrl = loadingCtrl;\n      this.bgService = bgService;\n      this.settingsService = settingsService;\n      this.zone = zone;\n      this.platform = platform;\n      this.isGoogleMapsSdkLoaded = typeof google === 'object';\n      // Event subscriptions\n      this.subscriptions = [];\n      // FAB Menu state.\n      this.isMainMenuOpen = false;\n      this.isMapMenuOpen = false;\n      this.isSyncing = false;\n      this.isResettingOdometer = false;\n      this.isEmailingLog = false;\n      this.isWatchingPosition = false;\n      this.testModeClicks = 0;\n      this.iconMap = ICON_MAP;\n      this.geofenceHits = [];\n      // Initial state\n      this.state = {\n        enabled: false,\n        isMoving: false,\n        geofenceProximityRadius: 1000,\n        trackingMode: 1,\n        isChangingPace: false,\n        activityIcon: this.iconMap['activity_unknown'],\n        odometer: 0,\n        provider: {\n          gps: true,\n          network: true,\n          enabled: true,\n          status: -1\n        },\n        containerBorder: 'none',\n        locationJson: ''\n      };\n      /// Listen to PAUSE/RESUME events for fun.\n      this.platform.pause.subscribe(() => {\n        console.log('************************** PAUSE');\n      });\n      this.platform.resume.subscribe(() => {\n        console.log('************************** RESUME');\n      });\n    }\n    ionViewWillEnter() {\n      return _asyncToGenerator(function* () {\n        console.log('⚙️ ionViewWillEnter');\n      })();\n    }\n    ngAfterContentInit() {\n      var _this = this;\n      return _asyncToGenerator(function* () {\n        console.log('⚙️ ngAfterContentInit');\n        // Setup the GoogleMap\n        yield _this.configureMap();\n        // Re-register Transistor Demo Server Authorization listener.\n        registerTransistorAuthorizationListener(_this.router);\n        // Configure the plugin.\n        _this.configureBackgroundGeolocation();\n      })();\n    }\n    ngOnInit() {}\n    ngOnDestroy() {\n      this.unsubscribe();\n    }\n    subscribe(subscription) {\n      this.subscriptions.push(subscription);\n    }\n    unsubscribe() {\n      this.subscriptions.forEach(subscription => subscription.remove());\n      this.subscriptions = [];\n    }\n    /**\n    * Configure BackgroundGeolocation plugin\n    */\n    configureBackgroundGeolocation() {\n      var _this2 = this;\n      return _asyncToGenerator(function* () {\n        var _ref;\n        // Listen to BackgroundGeolocation events.  Each BackgroundGeolocation event-listener returns a Subscription\n        // instance containing only a .remove() method used for unsubscribing from the event.\n        // We manage a collection of these Subscriptions so we can unsubscribe when the view is destroyed or refreshed during\n        // development with --livereload (@see ngOnDestroy above).\n        //\n        _this2.subscribe(BackgroundGeolocation.onLocation(_this2.onLocation.bind(_this2), _this2.onLocationError.bind(_this2)));\n        _this2.subscribe(BackgroundGeolocation.onMotionChange(_this2.onMotionChange.bind(_this2)));\n        _this2.subscribe(BackgroundGeolocation.onHeartbeat(_this2.onHeartbeat.bind(_this2)));\n        _this2.subscribe(BackgroundGeolocation.onGeofence(_this2.onGeofence.bind(_this2)));\n        _this2.subscribe(BackgroundGeolocation.onActivityChange(_this2.onActivityChange.bind(_this2)));\n        _this2.subscribe(BackgroundGeolocation.onProviderChange(_this2.onProviderChange.bind(_this2)));\n        _this2.subscribe(BackgroundGeolocation.onGeofencesChange(_this2.onGeofencesChange.bind(_this2)));\n        _this2.subscribe(BackgroundGeolocation.onSchedule(_this2.onSchedule.bind(_this2)));\n        _this2.subscribe(BackgroundGeolocation.onHttp(_this2.onHttp.bind(_this2)));\n        _this2.subscribe(BackgroundGeolocation.onPowerSaveChange(_this2.onPowerSaveChange.bind(_this2)));\n        _this2.subscribe(BackgroundGeolocation.onConnectivityChange(_this2.onConnectivityChange.bind(_this2)));\n        _this2.subscribe(BackgroundGeolocation.onEnabledChange(_this2.onEnabledChange.bind(_this2)));\n        _this2.subscribe(BackgroundGeolocation.onNotificationAction(_this2.onNotificationAction.bind(_this2)));\n        /// A Big red border is rendered around view when the device is in \"Power Saving Mode\".\n        _this2.state.containerBorder = (yield BackgroundGeolocation.isPowerSaveMode()) ? CONTAINER_BORDER_POWER_SAVE_ON : CONTAINER_BORDER_POWER_SAVE_OFF;\n        const orgname = LocalStorage.getItem('orgname');\n        const username = LocalStorage.getItem('username');\n        let token = yield BackgroundGeolocation.findOrCreateTransistorAuthorizationToken(orgname, username, environment.TRACKER_HOST);\n        // With the plugin's #ready method, the supplied config object will only be applied with the first\n        // boot of your application.  The plugin persists the configuration you apply to it.  Each boot thereafter,\n        // the plugin will automatically apply the last known configuration.\n        BackgroundGeolocation.ready({\n          transistorAuthorizationToken: token,\n          reset: false,\n          debug: true,\n          locationAuthorizationRequest: 'Always',\n          logLevel: BackgroundGeolocation.LOG_LEVEL_VERBOSE,\n          backgroundPermissionRationale: {\n            title: \"Allow {applicationName} to access this device's location even when closed or not in use.\",\n            message: \"This app collects location data to enable recording your trips to work and calculate distance-travelled.\",\n            positiveAction: 'Change to \"{backgroundPermissionOptionLabel}\"',\n            negativeAction: 'Cancel'\n          },\n          distanceFilter: 10,\n          stopTimeout: 1,\n          stopOnTerminate: false,\n          startOnBoot: true,\n          enableHeadless: true,\n          autoSync: true,\n          maxDaysToPersist: 14\n        }).then(function (_x) {\n          return (_ref = _ref || _asyncToGenerator(function* (state) {\n            // Store the plugin state onto ourself for convenience.\n            console.log('- BackgroundGeolocation is ready: ', state);\n            _this2.zone.run(() => {\n              _this2.state.enabled = state.enabled;\n              _this2.state.isMoving = state.isMoving;\n              _this2.state.geofenceProximityRadius = state.geofenceProximityRadius;\n              _this2.state.trackingMode = state.trackingMode;\n              if (state.schedule.length > 0) {\n                BackgroundGeolocation.startSchedule();\n              }\n            });\n          })).apply(this, arguments);\n        }).catch(error => {\n          console.warn('- BackgroundGeolocation configuration error: ', error);\n        });\n      })();\n    }\n    /**\n    * Configure Google Maps\n    */\n    configureMap() {\n      return new Promise(resolve => {\n        // Handle case where app booted without network accesss (google maps lib fails to load)\n        if (!this.isGoogleMapsSdkLoaded) {\n          console.warn('- map not loaded');\n          return;\n        }\n        this.locationMarkers = [];\n        this.geofenceMarkers = [];\n        this.geofenceHitMarkers = [];\n        let latLng = new google.maps.LatLng(-34.9290, 138.6010);\n        let mapOptions = {\n          center: latLng,\n          zoom: 15,\n          mapTypeId: google.maps.MapTypeId.ROADMAP,\n          zoomControl: false,\n          mapTypeControl: false,\n          panControl: false,\n          rotateControl: false,\n          scaleControl: false,\n          streetViewControl: false,\n          disableDefaultUI: true\n        };\n        this.map = new google.maps.Map(this.mapElement.nativeElement, mapOptions);\n        // Create LongPress event-handler\n        new LongPress(this.map, 500);\n        // Tap&hold detected.  Play a sound a draw a circular cursor.\n        google.maps.event.addListener(this.map, 'longpresshold', this.onLongPressStart.bind(this));\n        // Longpress cancelled.  Get rid of the circle cursor.\n        google.maps.event.addListener(this.map, 'longpresscancel', this.onLongPressCancel.bind(this));\n        // Longpress initiated, add the geofence\n        google.maps.event.addListener(this.map, 'longpress', this.onLongPress.bind(this));\n        // Blue current location marker\n        this.currentLocationMarker = new google.maps.Marker({\n          zIndex: 10,\n          map: this.map,\n          title: 'Current Location',\n          icon: {\n            path: google.maps.SymbolPath.CIRCLE,\n            scale: 12,\n            fillColor: COLORS.blue,\n            fillOpacity: 1,\n            strokeColor: COLORS.white,\n            strokeOpacity: 1,\n            strokeWeight: 6\n          }\n        });\n        // Light blue location accuracy circle\n        this.locationAccuracyCircle = new google.maps.Circle({\n          map: this.map,\n          zIndex: 9,\n          fillColor: COLORS.light_blue,\n          fillOpacity: 0.4,\n          strokeOpacity: 0\n        });\n        // Stationary Geofence\n        this.stationaryRadiusCircle = new google.maps.Circle({\n          zIndex: 0,\n          fillColor: COLORS.red,\n          strokeColor: COLORS.red,\n          strokeWeight: 1,\n          fillOpacity: 0.3,\n          strokeOpacity: 0.7,\n          map: this.map\n        });\n        // Route polyline\n        let seq = {\n          repeat: '30px',\n          icon: {\n            path: google.maps.SymbolPath.FORWARD_OPEN_ARROW,\n            scale: 1,\n            fillOpacity: 0,\n            strokeColor: COLORS.white,\n            strokeWeight: 1,\n            strokeOpacity: 1\n          }\n        };\n        this.polyline = new google.maps.Polyline({\n          map: this.map,\n          zIndex: 1,\n          geodesic: true,\n          strokeColor: COLORS.polyline_color,\n          strokeOpacity: 0.7,\n          strokeWeight: 7,\n          icons: [seq]\n        });\n        // Popup geofence cursor for adding geofences via LongPress\n        this.geofenceCursor = new google.maps.Marker({\n          clickable: false,\n          zIndex: 100,\n          icon: {\n            path: google.maps.SymbolPath.CIRCLE,\n            scale: 100,\n            fillColor: COLORS.green,\n            fillOpacity: 0.2,\n            strokeColor: COLORS.green,\n            strokeWeight: 1,\n            strokeOpacity: 0.7\n          }\n        });\n        resolve();\n      });\n    }\n    ////\n    // UI event handlers\n    //\n    onClickMainMenu() {\n      var _this3 = this;\n      return _asyncToGenerator(function* () {\n        _this3.isMainMenuOpen = !_this3.isMainMenuOpen;\n        if (_this3.isMainMenuOpen) {\n          _this3.bgService.playSound('OPEN');\n        } else {\n          _this3.bgService.playSound('CLOSE');\n        }\n      })();\n    }\n    onClickSettings() {\n      var _this4 = this;\n      return _asyncToGenerator(function* () {\n        var _ref2;\n        _this4.bgService.playSound('OPEN');\n        const modal = yield _this4.modalController.create({\n          component: SettingsPage,\n          cssClass: 'my-custom-class',\n          animated: true,\n          componentProps: {\n            'bgService': _this4.bgService,\n            'settingsService': _this4.settingsService\n          }\n        });\n        modal.onDidDismiss().then(function (_x2) {\n          return (_ref2 = _ref2 || _asyncToGenerator(function* (result) {\n            // Update our view-state -- BackgroundGeolocation state may have changed in Settings screen.\n            const state = yield BackgroundGeolocation.getState();\n            _this4.state.enabled = state.enabled;\n            _this4.state.isMoving = state.isMoving;\n            _this4.state.geofenceProximityRadius = state.geofenceProximityRadius;\n            _this4.state.trackingMode = state.trackingMode;\n          })).apply(this, arguments);\n        });\n        yield modal.present();\n      })();\n    }\n    onClickRequestPermission() {\n      var _this5 = this;\n      return _asyncToGenerator(function* () {\n        let providerState = yield BackgroundGeolocation.getProviderState();\n        const alert = yield _this5.alertCtrl.create({\n          header: 'Request Permission',\n          message: `Current Authorization Status: ${providerState.status}`,\n          cssClass: 'alert-wide',\n          buttons: [{\n            text: 'When in Use',\n            handler: () => {\n              _this5.requestPermission('WhenInUse');\n            }\n          }, {\n            text: 'Always',\n            handler: () => {\n              _this5.requestPermission('Always');\n            }\n          }]\n        });\n        alert.present();\n      })();\n    }\n    requestPermission(request) {\n      var _this6 = this;\n      return _asyncToGenerator(function* () {\n        yield BackgroundGeolocation.setConfig({\n          locationAuthorizationRequest: request\n        });\n        let status = yield BackgroundGeolocation.requestPermission();\n        console.log('[requestPermission] status:', status);\n        const alert = yield _this6.alertCtrl.create({\n          header: 'Permission Result',\n          message: `Authorization Status: ${status}`,\n          cssClass: 'alert-wide',\n          buttons: [{\n            text: 'Ok',\n            handler: () => {}\n          }]\n        });\n        alert.present();\n      })();\n    }\n    onClickSync() {\n      var _this7 = this;\n      return _asyncToGenerator(function* () {\n        _this7.bgService.playSound('BUTTON_CLICK');\n        const onComplete = (message, result) => {\n          _this7.settingsService.toast(message, result);\n          _this7.isSyncing = false;\n        };\n        const count = yield BackgroundGeolocation.getCount();\n        if (!count) {\n          _this7.settingsService.toast('Database is empty.');\n          return;\n        }\n        const message = 'Sync ' + count + ' location' + (count > 1 ? 's' : '') + '?';\n        _this7.settingsService.confirm('Confirm Sync', message, () => {\n          _this7.isSyncing = true;\n          BackgroundGeolocation.sync().then(rs => {\n            _this7.bgService.playSound('MESSAGE_SENT');\n            onComplete(MESSAGE.sync_success, count);\n          }).catch(error => {\n            onComplete(MESSAGE.sync_failure, error);\n          });\n        });\n      })();\n    }\n    onClickDestroyLocations() {\n      var _this8 = this;\n      return _asyncToGenerator(function* () {\n        _this8.bgService.playSound('BUTTON_CLICK');\n        let settingsService = _this8.settingsService;\n        const onComplete = (message, result) => {\n          settingsService.toast(message, result);\n          _this8.isDestroyingLocations = false;\n        };\n        let count = yield BackgroundGeolocation.getCount();\n        if (!count) {\n          _this8.settingsService.toast('Locations database is empty');\n          return;\n        }\n        // Confirm destroy\n        let message = 'Destroy ' + count + ' location' + (count > 1 ? 's' : '') + '?';\n        _this8.settingsService.confirm('Confirm Delete', message, () => {\n          // Good to go...\n          _this8.isDestroyingLocations = true;\n          BackgroundGeolocation.destroyLocations().then(result => {\n            _this8.bgService.playSound('MESSAGE_SENT');\n            onComplete.call(_this8, MESSAGE.destroy_locations_success, count);\n          }).catch(error => {\n            onComplete.call(_this8, MESSAGE.destroy_locations_failure, error);\n          });\n        });\n      })();\n    }\n    onClickEmailLogs() {\n      var _this9 = this;\n      return _asyncToGenerator(function* () {\n        _this9.bgService.playSound('BUTTON_CLICK');\n        const email = LocalStorage.getItem('settings:email');\n        if (!email) {\n          // Prompt user to enter a unique identifier for tracker.transistorsoft.com\n          const prompt = yield _this9.alertCtrl.create({\n            backdropDismiss: false,\n            header: 'Email Logs',\n            message: 'Please enter your email address',\n            inputs: [{\n              name: 'email',\n              placeholder: 'Email address'\n            }],\n            buttons: [{\n              text: 'Cancel',\n              handler: data => {\n                prompt.dismiss();\n              }\n            }, {\n              text: 'OK',\n              handler: data => {\n                if (data.email.length < 1) {\n                  return;\n                }\n                LocalStorage.setItem('settings:email', data.email);\n                _this9.doEmailLog(data.email);\n              }\n            }]\n          });\n          prompt.present();\n        } else {\n          _this9.doEmailLog(email);\n        }\n      })();\n    }\n    doEmailLog(email) {\n      var _this10 = this;\n      return _asyncToGenerator(function* () {\n        const spinner = yield _this10.loadingCtrl.create({\n          cssClass: 'my-custom-class',\n          message: 'Preparing logs...'\n        });\n        spinner.present();\n        _this10.isEmailingLog = true;\n        BackgroundGeolocation.logger.emailLog(email).then(result => {\n          spinner.dismiss();\n          _this10.isEmailingLog = false;\n        }).catch(error => {\n          spinner.dismiss();\n          _this10.isEmailingLog = false;\n          console.warn('- email log failed: ', error);\n        });\n      })();\n    }\n    onClickResetOdometer() {\n      this.state.odometer = '0.0';\n      this.bgService.playSound('BUTTON_CLICK');\n      this.isResettingOdometer = true;\n      this.resetMarkers();\n      let settingsService = this.settingsService;\n      const onComplete = (message, result) => {\n        settingsService.toast(message, result);\n        this.isResettingOdometer = false;\n      };\n      BackgroundGeolocation.resetOdometer().then(location => {\n        onComplete.call(this, MESSAGE.reset_odometer_success);\n      }).catch(error => {\n        onComplete.call(this, MESSAGE.reset_odometer_failure, error);\n      });\n    }\n    // Return to Home screen (app switcher)\n    onClickHome() {\n      this.navCtrl.navigateBack('/home');\n    }\n    onToggleEnabled() {\n      var _this11 = this;\n      return _asyncToGenerator(function* () {\n        const state = yield BackgroundGeolocation.getState();\n        if (state.enabled === _this11.state.enabled) {\n          // The plugin is already in the desired state.  Ignored.  onToggleEnabled fires on initial boot.\n          return;\n        }\n        _this11.bgService.playSound('BUTTON_CLICK');\n        if (_this11.state.enabled) {\n          let onSuccess = state => {\n            console.log('[js] START SUCCESS :', state);\n          };\n          let onFailure = error => {\n            console.error('[js] START FAILURE: ', error);\n          };\n          if (_this11.state.trackingMode == 1) {\n            BackgroundGeolocation.start().then(onSuccess).catch(onFailure);\n          } else {\n            BackgroundGeolocation.startGeofences().then(onSuccess).catch(onFailure);\n          }\n        } else {\n          yield BackgroundGeolocation.stop();\n          _this11.state.isMoving = false;\n          _this11.clearMarkers();\n        }\n      })();\n    }\n    onClickWatchPosition() {\n      this.isWatchingPosition = !this.isWatchingPosition;\n      if (this.isWatchingPosition) {\n        BackgroundGeolocation.watchPosition(location => {\n          console.log('*** [watchPosition]', location);\n        }, error => {\n          console.warn('*** [watchPosition] ERROR: ', error);\n        }, {\n          interval: 1000\n        });\n      } else {\n        BackgroundGeolocation.stopWatchPosition();\n      }\n    }\n    onClickGetCurrentPosition() {\n      this.bgService.playSound('BUTTON_CLICK');\n      BackgroundGeolocation.getCurrentPosition({\n        maximumAge: 0,\n        desiredAccuracy: 100,\n        samples: 1,\n        persist: true,\n        timeout: 30,\n        extras: {\n          foo: 'bar'\n        }\n      }).then(location => {\n        console.log('[js] getCurrentPosition: ', location);\n      }).catch(error => {\n        console.warn('[js] getCurrentPosition FAILURE: ', error);\n      });\n    }\n    /**\n    * My private test mode.  DO NOT USE\n    * @private\n    */\n    onClickTestMode() {\n      this.bgService.playSound('TEST_MODE_CLICK');\n      this.testModeClicks++;\n      if (this.testModeClicks == 10) {\n        this.bgService.playSound('TEST_MODE_SUCCESS');\n        this.settingsService.applyTestConfig();\n      }\n      if (this.testModeTimer > 0) clearTimeout(this.testModeTimer);\n      this.testModeTimer = setTimeout(() => {\n        this.testModeClicks = 0;\n      }, 2000);\n    }\n    onClickChangePace() {\n      if (!this.state.enabled) {\n        return;\n      }\n      const onComplete = () => {\n        this.state.isChangingPace = false;\n      };\n      this.bgService.playSound('BUTTON_CLICK');\n      this.state.isChangingPace = true;\n      this.state.isMoving = !this.state.isMoving;\n      BackgroundGeolocation.changePace(this.state.isMoving).then(onComplete).catch(onComplete);\n    }\n    ////\n    // Background Geolocation event-listeners\n    //\n    /**\n    * @event location\n    */\n    onLocation(location) {\n      console.log('[location] -', JSON.stringify(location, null, 2));\n      // Print a log message to SDK's logger to prove this executed, even in the background.\n      BackgroundGeolocation.logger.debug(\"👍 [onLocation] received location in Javascript: \" + location.uuid);\n      if (!this.isGoogleMapsSdkLoaded) {\n        this.zone.run(() => {\n          this.state.locationJson = JSON.stringify(location, null, 2);\n        });\n        return;\n      }\n      this.zone.run(() => {\n        this.setCenter(location);\n        if (!location.sample) {\n          // Convert meters -> km -> round nearest hundredth -> fix float xxx.x\n          this.state.odometer = parseFloat((Math.round(location.odometer / 1000 * 10) / 10).toString()).toFixed(1);\n        }\n      });\n    }\n    /**\n    * @event location failure\n    */\n    onLocationError(error) {\n      console.warn('[location] - ERROR: ', error);\n    }\n    /**\n    * @event motionchange\n    */\n    onMotionChange(event) {\n      console.log('[motionchange] -', event.isMoving, event.location);\n      if (!this.isGoogleMapsSdkLoaded) {\n        return;\n      }\n      this.zone.run(() => {\n        if (event.isMoving) {\n          this.hideStationaryCircle();\n        } else {\n          this.showStationaryCircle(event.location);\n        }\n        this.state.enabled = true;\n        this.state.isChangingPace = false;\n        this.state.isMoving = event.isMoving;\n      });\n    }\n    /**\n    * @event heartbeat\n    */\n    onHeartbeat(event) {\n      console.log('[heartbeat] -', event);\n    }\n    /**\n    * @event activitychange\n    */\n    onActivityChange(event) {\n      console.log('[activitychange] -', event.activity, event.confidence);\n      if (!this.isGoogleMapsSdkLoaded) {\n        return;\n      }\n      this.zone.run(() => {\n        this.state.activityName = event.activity;\n        this.state.activityIcon = this.iconMap['activity_' + event.activity];\n      });\n    }\n    /**\n    * @event providerchange\n    */\n    onProviderChange(event) {\n      console.log('[providerchange] -', event);\n      if (event.status == BackgroundGeolocation.AUTHORIZATION_STATUS_ALWAYS && event.accuracyAuthorization == BackgroundGeolocation.ACCURACY_AUTHORIZATION_REDUCED) {\n        // Supply \"Purpose\" key from Info.plist as 1st argument.\n        BackgroundGeolocation.requestTemporaryFullAccuracy(\"DemoPurpose\").then(accuracyAuthorization => {\n          if (accuracyAuthorization == BackgroundGeolocation.ACCURACY_AUTHORIZATION_FULL) {\n            console.log(`[requestTemporaryFullAccuracy] GRANTED:  ${accuracyAuthorization}`);\n          } else {\n            console.log(`[requestTemporaryFullAccuracy] DENIED:  ${accuracyAuthorization}`);\n          }\n        }).catch(error => {\n          console.log(`[requestTemporaryFullAccuracy] FAILED TO SHOW DIALOG: ${error}`);\n        });\n      }\n      switch (event.status) {\n        case BackgroundGeolocation.AUTHORIZATION_STATUS_DENIED:\n          break;\n        case BackgroundGeolocation.AUTHORIZATION_STATUS_ALWAYS:\n          break;\n        case BackgroundGeolocation.AUTHORIZATION_STATUS_WHEN_IN_USE:\n          break;\n      }\n      this.zone.run(() => {\n        this.state.provider = event;\n      });\n    }\n    /**\n    * @event geofenceschange\n    */\n    onGeofencesChange(event) {\n      console.log('[geofenceschange] -', event);\n      if (!this.isGoogleMapsSdkLoaded) {\n        return;\n      }\n      // All geofences off\n      if (!event.on.length && !event.off.length) {\n        this.geofenceMarkers.forEach(circle => {\n          circle.setMap(null);\n        });\n        this.geofenceMarkers = [];\n        return;\n      }\n      // Filter out all \"off\" geofences.\n      this.geofenceMarkers = this.geofenceMarkers.filter(circle => {\n        if (event.off.indexOf(circle.identifier) < 0) {\n          return true;\n        } else {\n          circle.setMap(null);\n          return false;\n        }\n      });\n      // Add new \"on\" geofences.\n      event.on.forEach(geofence => {\n        var circle = this.geofenceMarkers.find(marker => {\n          return marker.identifier === geofence.identifier;\n        });\n        // Already added?\n        if (circle) {\n          return;\n        }\n        this.geofenceMarkers.push(this.buildGeofenceMarker(geofence));\n      });\n    }\n    /**\n    * @event geofence\n    */\n    onGeofence(event) {\n      var _this12 = this;\n      return _asyncToGenerator(function* () {\n        console.log('[geofence] -', event);\n        if (!_this12.isGoogleMapsSdkLoaded) {\n          return;\n        }\n        var circle = _this12.geofenceMarkers.find(marker => {\n          return marker.identifier === event.identifier;\n        });\n        if (!circle) {\n          return;\n        }\n        var map = _this12.map;\n        let location = event.location;\n        let geofenceMarker = _this12.geofenceHits[event.identifier];\n        if (!geofenceMarker) {\n          geofenceMarker = {\n            circle: new google.maps.Circle({\n              zIndex: 100,\n              fillOpacity: 0,\n              strokeColor: COLORS.black,\n              strokeWeight: 1,\n              strokeOpacity: 1,\n              radius: circle.getRadius() + 1,\n              center: circle.getCenter(),\n              map: map\n            }),\n            events: []\n          };\n          _this12.geofenceHits[event.identifier] = geofenceMarker;\n          _this12.geofenceHitMarkers.push(geofenceMarker.circle);\n        }\n        var color;\n        if (event.action === 'ENTER') {\n          color = COLORS.green;\n        } else if (event.action === 'DWELL') {\n          color = COLORS.gold;\n        } else {\n          color = COLORS.red;\n        }\n        let circleLatLng = geofenceMarker.circle.getCenter();\n        let locationLatLng = new google.maps.LatLng(location.coords.latitude, location.coords.longitude);\n        let distance = google.maps.geometry.spherical.computeDistanceBetween(circleLatLng, locationLatLng);\n        // Push event\n        geofenceMarker.events.push({\n          action: event.action,\n          location: event.location,\n          distance: distance\n        });\n        let heading = google.maps.geometry.spherical.computeHeading(circleLatLng, locationLatLng);\n        let circleEdgeLatLng = google.maps.geometry.spherical.computeOffset(circleLatLng, geofenceMarker.circle.getRadius(), heading);\n        geofenceMarker.events.push({\n          location: event.location,\n          action: event.action,\n          distance: distance\n        });\n        var geofenceEdgeMarker = new google.maps.Marker({\n          zIndex: 1000,\n          icon: {\n            path: google.maps.SymbolPath.CIRCLE,\n            scale: 5,\n            fillColor: color,\n            fillOpacity: 0.7,\n            strokeColor: COLORS.black,\n            strokeWeight: 1,\n            strokeOpacity: 1\n          },\n          map: map,\n          position: circleEdgeLatLng\n        });\n        _this12.geofenceHitMarkers.push(geofenceEdgeMarker);\n        var locationMarker = _this12.buildLocationMarker(location, {\n          showHeading: true\n        });\n        locationMarker.setMap(map);\n        _this12.geofenceHitMarkers.push(locationMarker);\n        var polyline = new google.maps.Polyline({\n          map: map,\n          zIndex: 1000,\n          geodesic: true,\n          strokeColor: COLORS.black,\n          strokeOpacity: 1,\n          strokeWeight: 1,\n          path: [circleEdgeLatLng, locationMarker.getPosition()]\n        });\n        _this12.geofenceHitMarkers.push(polyline);\n        // Change the color of activated geofence to light-grey.\n        circle.activated = true;\n        circle.setOptions({\n          fillColor: COLORS.grey,\n          fillOpacity: 0.2,\n          strokeColor: COLORS.grey,\n          strokeOpacity: 0.4\n        });\n      })();\n    }\n    /**\n    * @event http\n    */\n    onHttp(response) {\n      if (response.success) {\n        console.log('[http] - success: ', response);\n      } else {\n        console.warn('[http] - FAILURE: ', response);\n      }\n    }\n    /**\n    * @event schedule\n    */\n    onSchedule(state) {\n      console.log('[schedule] - ', state);\n      this.zone.run(() => {\n        this.state.enabled = state.enabled;\n      });\n    }\n    /**\n    * @event powersavechange\n    */\n    onPowerSaveChange(isPowerSaveMode) {\n      console.log('[js powersavechange: ', isPowerSaveMode);\n      this.settingsService.toast('Power-save mode: ' + (isPowerSaveMode ? 'ON' : 'OFF'), null, 5000);\n      this.zone.run(() => {\n        this.state.containerBorder = isPowerSaveMode ? CONTAINER_BORDER_POWER_SAVE_ON : CONTAINER_BORDER_POWER_SAVE_OFF;\n      });\n    }\n    /**\n    * @event connectivitychange\n    */\n    onConnectivityChange(event) {\n      this.settingsService.toast('connectivitychange: ' + event.connected);\n      console.log('[connectivitychange] -', event);\n    }\n    /**\n    * @event enabledchange\n    */\n    onEnabledChange(enabled) {\n      this.settingsService.toast('enabledchange: ' + enabled);\n      console.log('[enabledchange] -', enabled);\n      this.zone.run(() => {\n        this.state.enabled = enabled;\n        this.state.isMoving = false;\n      });\n    }\n    /**\n    * @event notificationaction\n    */\n    onNotificationAction(buttonId) {\n      console.log('[notificationaction] -', buttonId);\n      switch (buttonId) {\n        case 'notificationButtonFoo':\n          break;\n        case 'notificaitonButtonBar':\n          break;\n      }\n    }\n    ////\n    // Google map methods\n    //\n    //\n    //\n    setCenter(location) {\n      if (!this.isGoogleMapsSdkLoaded) {\n        return;\n      }\n      this.updateCurrentLocationMarker(location);\n      setTimeout(function () {\n        this.map.setCenter(new google.maps.LatLng(location.coords.latitude, location.coords.longitude));\n      }.bind(this));\n    }\n    updateCurrentLocationMarker(location) {\n      var latlng = new google.maps.LatLng(location.coords.latitude, location.coords.longitude);\n      this.currentLocationMarker.setPosition(latlng);\n      this.locationAccuracyCircle.setCenter(latlng);\n      this.locationAccuracyCircle.setRadius(location.coords.accuracy);\n      if (location.sample === true) {\n        return;\n      }\n      if (this.lastLocation) {\n        this.locationMarkers.push(this.buildLocationMarker(location));\n      }\n      // Add breadcrumb to current Polyline path.\n      this.polyline.getPath().push(latlng);\n      if (!this.state.mapHidePolyline) {\n        this.polyline.setMap(this.map);\n      }\n      this.lastLocation = location;\n    }\n    // Build a bread-crumb location marker.\n    buildLocationMarker(location, options) {\n      options = options || {};\n      var icon = google.maps.SymbolPath.CIRCLE;\n      var scale = 3;\n      var zIndex = 1;\n      var anchor;\n      var strokeWeight = 1;\n      if (!this.lastDirectionChangeLocation) {\n        this.lastDirectionChangeLocation = location;\n      }\n      // Render an arrow marker if heading changes by 10 degrees or every 5 points.\n      var deltaHeading = Math.abs(location.coords.heading - this.lastDirectionChangeLocation.coords.heading);\n      if (deltaHeading >= 15 || !(this.locationMarkers.length % 5) || options.showHeading) {\n        icon = google.maps.SymbolPath.FORWARD_CLOSED_ARROW;\n        scale = 2;\n        strokeWeight = 1;\n        anchor = new google.maps.Point(0, 2.6);\n        this.lastDirectionChangeLocation = location;\n      }\n      return new google.maps.Marker({\n        zIndex: zIndex,\n        icon: {\n          path: icon,\n          rotation: location.coords.heading,\n          scale: scale,\n          anchor: anchor,\n          fillColor: COLORS.polyline_color,\n          fillOpacity: 1,\n          strokeColor: COLORS.black,\n          strokeWeight: strokeWeight,\n          strokeOpacity: 1\n        },\n        map: this.map,\n        position: new google.maps.LatLng(location.coords.latitude, location.coords.longitude)\n      });\n    }\n    buildGeofenceMarker(geofence) {\n      // Add longpress event for adding GeoFence of hard-coded radius 200m.\n      var circle = new google.maps.Circle({\n        identifier: geofence.identifier,\n        zIndex: 100,\n        fillColor: COLORS.green,\n        fillOpacity: 0.2,\n        strokeColor: COLORS.green,\n        strokeWeight: 1,\n        strokeOpacity: 0.7,\n        params: geofence,\n        radius: geofence.radius,\n        center: new google.maps.LatLng(geofence.latitude, geofence.longitude),\n        map: this.map\n      });\n      // Add 'click' listener to geofence so we can edit it.\n      google.maps.event.addListener(geofence, 'click', () => {\n        this.settingsService.toast('Click geofence ' + geofence.identifier, null, 1000);\n      });\n      return circle;\n    }\n    buildStopZoneMarker(latlng) {\n      return new google.maps.Marker({\n        zIndex: 1,\n        map: this.map,\n        position: latlng,\n        icon: {\n          path: google.maps.SymbolPath.CIRCLE,\n          scale: 12,\n          fillColor: COLORS.red,\n          fillOpacity: 0.3,\n          strokeColor: COLORS.red,\n          strokeWeight: 1,\n          strokeOpacity: 0.7\n        }\n      });\n    }\n    showStationaryCircle(location) {\n      var coords = location.coords;\n      var radius = this.state.trackingMode == 1 ? 200 : this.state.geofenceProximityRadius / 2;\n      var center = new google.maps.LatLng(coords.latitude, coords.longitude);\n      this.stationaryRadiusCircle.setRadius(radius);\n      this.stationaryRadiusCircle.setCenter(center);\n      this.stationaryRadiusCircle.setMap(this.map);\n      this.map.setCenter(center);\n    }\n    hideStationaryCircle() {\n      // Create a little red breadcrumb circle of our last stop-position\n      var latlng = this.stationaryRadiusCircle.getCenter();\n      var stopZone = this.buildStopZoneMarker(latlng);\n      var lastMarker = this.locationMarkers.pop();\n      if (lastMarker) {\n        lastMarker.setMap(null);\n      }\n      this.locationMarkers.push(stopZone);\n      this.stationaryRadiusCircle.setMap(null);\n    }\n    resetMarkers() {\n      if (!this.isGoogleMapsSdkLoaded) {\n        return;\n      }\n      // Clear location-markers.\n      this.locationMarkers.forEach(marker => {\n        marker.setMap(null);\n      });\n      this.locationMarkers = [];\n      // Clear geofence hit markers\n      this.geofenceHitMarkers.forEach(marker => {\n        marker.setMap(null);\n      });\n      this.polyline.setPath([]);\n    }\n    clearMarkers() {\n      if (!this.isGoogleMapsSdkLoaded) {\n        return;\n      }\n      this.resetMarkers();\n      this.geofenceMarkers.forEach(marker => {\n        marker.setMap(null);\n      });\n      this.geofenceMarkers = [];\n      // Clear red stationaryRadius marker\n      this.stationaryRadiusCircle.setMap(null);\n      // Clear blue route PolyLine\n      this.polyline.setMap(null);\n      this.polyline.setPath([]);\n    }\n    alert(title, message) {}\n    ////\n    // Map events\n    //\n    onLongPressStart(e) {\n      this.bgService.playSound('LONG_PRESS_ACTIVATE');\n      this.geofenceCursor.setPosition(e.latLng);\n      this.geofenceCursor.setMap(this.map);\n    }\n    onLongPressCancel(e) {\n      this.bgService.playSound('LONG_PRESS_CANCEL');\n      this.geofenceCursor.setMap(null);\n    }\n    onLongPress(e) {\n      var _this13 = this;\n      return _asyncToGenerator(function* () {\n        var latlng = e.latLng;\n        _this13.geofenceCursor.setMap(null);\n        const modal = yield _this13.modalController.create({\n          component: GeofencePage,\n          cssClass: 'my-custom-class',\n          animated: true,\n          componentProps: {\n            bgService: _this13.bgService,\n            'latitude': latlng.lat(),\n            'longitude': latlng.lng()\n          }\n        });\n        yield modal.present();\n      })();\n    }\n  }\n  _class = AdvancedPage;\n  _class.ɵfac = function AdvancedPage_Factory(t) {\n    return new (t || _class)(i0.ɵɵdirectiveInject(i1.NavController), i0.ɵɵdirectiveInject(i1.AlertController), i0.ɵɵdirectiveInject(i2.Router), i0.ɵɵdirectiveInject(i1.ModalController), i0.ɵɵdirectiveInject(i1.LoadingController), i0.ɵɵdirectiveInject(i3.BGService), i0.ɵɵdirectiveInject(i4.SettingsService), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i1.Platform));\n  };\n  _class.ɵcmp = /*@__PURE__*/i0.ɵɵdefineComponent({\n    type: _class,\n    selectors: [[\"app-advanced\"]],\n    viewQuery: function AdvancedPage_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c0, 7);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.mapElement = _t.first);\n      }\n    },\n    decls: 64,\n    vars: 28,\n    consts: [[\"color\", \"tertiary\"], [\"mode\", \"ios\", \"color\", \"dark\"], [\"slot\", \"start\"], [3, \"click\"], [\"name\", \"home\"], [\"slot\", \"end\"], [2, \"display\", \"block\", 3, \"ngModel\", \"ngModelChange\", \"ionChange\"], [3, \"ngStyle\"], [\"slot\", \"fixed\", \"vertical\", \"bottom\", \"horizontal\", \"end\"], [\"fab\", \"\"], [\"color\", \"tertiary\", 3, \"click\"], [\"color\", \"dark\", \"name\", \"add\"], [\"side\", \"top\"], [\"name\", \"cog\"], [\"name\", \"lock-open-outline\"], [\"name\", \"circles\", \"color\", \"dark\", 3, \"hidden\"], [\"name\", \"speedometer\", 3, \"hidden\"], [\"name\", \"mail\", 3, \"hidden\"], [\"name\", \"cloud-upload\", 3, \"hidden\"], [\"name\", \"trash\", 3, \"hidden\"], [\"id\", \"map\", 2, \"height\", \"100%\", \"width\", \"100%\"], [\"map\", \"\"], [3, \"hidden\"], [2, \"padding\", \"10px\"], [2, \"font-size\", \"10px\"], [\"mode\", \"ios\", \"color\", \"tertiary\"], [\"fill\", \"solid\", \"color\", \"primary\", 2, \"width\", \"50px\", 3, \"click\"], [\"name\", \"navigate-outline\"], [2, \"background-color\", \"transparent\", 3, \"click\"], [\"color\", \"dark\", 3, \"hidden\", \"name\"], [\"color\", \"danger\", 3, \"hidden\", \"name\"], [\"ion-text\", \"\", \"color\", \"\", 1, \"label\"], [\"color\", \"\", 3, \"name\"], [\"ion-text\", \"\", \"color\", \"\", 1, \"odometer\"], [\"fill\", \"solid\", 2, \"width\", \"50px\", 3, \"disabled\", \"color\", \"click\"], [\"name\", \"dots\", \"color\", \"light\", 3, \"hidden\"], [3, \"hidden\", \"name\"]],\n    template: function AdvancedPage_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"ion-header\")(1, \"ion-toolbar\", 0)(2, \"ion-title\", 1);\n        i0.ɵɵtext(3, \"BG Geolocation Demo\");\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(4, \"ion-buttons\", 2)(5, \"ion-button\", 3);\n        i0.ɵɵlistener(\"click\", function AdvancedPage_Template_ion_button_click_5_listener() {\n          return ctx.onClickHome();\n        });\n        i0.ɵɵelement(6, \"ion-icon\", 4);\n        i0.ɵɵelementEnd()();\n        i0.ɵɵelementStart(7, \"ion-buttons\", 5)(8, \"ion-toggle\", 6);\n        i0.ɵɵlistener(\"ngModelChange\", function AdvancedPage_Template_ion_toggle_ngModelChange_8_listener($event) {\n          return ctx.state.enabled = $event;\n        })(\"ionChange\", function AdvancedPage_Template_ion_toggle_ionChange_8_listener() {\n          return ctx.onToggleEnabled();\n        });\n        i0.ɵɵelementEnd()()()();\n        i0.ɵɵelementStart(9, \"ion-content\", 7)(10, \"ion-fab\", 8, 9)(12, \"ion-fab-button\", 10);\n        i0.ɵɵlistener(\"click\", function AdvancedPage_Template_ion_fab_button_click_12_listener() {\n          return ctx.onClickMainMenu();\n        });\n        i0.ɵɵelement(13, \"ion-icon\", 11);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(14, \"ion-fab-list\", 12)(15, \"ion-fab-button\", 10);\n        i0.ɵɵlistener(\"click\", function AdvancedPage_Template_ion_fab_button_click_15_listener() {\n          return ctx.onClickSettings();\n        });\n        i0.ɵɵelement(16, \"ion-icon\", 13);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(17, \"ion-fab-button\", 10);\n        i0.ɵɵlistener(\"click\", function AdvancedPage_Template_ion_fab_button_click_17_listener() {\n          return ctx.onClickRequestPermission();\n        });\n        i0.ɵɵelement(18, \"ion-icon\", 14);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(19, \"ion-fab-button\", 10);\n        i0.ɵɵlistener(\"click\", function AdvancedPage_Template_ion_fab_button_click_19_listener() {\n          return ctx.onClickResetOdometer();\n        });\n        i0.ɵɵelement(20, \"ion-spinner\", 15)(21, \"ion-icon\", 16);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(22, \"ion-fab-button\", 10);\n        i0.ɵɵlistener(\"click\", function AdvancedPage_Template_ion_fab_button_click_22_listener() {\n          return ctx.onClickEmailLogs();\n        });\n        i0.ɵɵelement(23, \"ion-spinner\", 15)(24, \"ion-icon\", 17);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(25, \"ion-fab-button\", 10);\n        i0.ɵɵlistener(\"click\", function AdvancedPage_Template_ion_fab_button_click_25_listener() {\n          return ctx.onClickSync();\n        });\n        i0.ɵɵelement(26, \"ion-spinner\", 15)(27, \"ion-icon\", 18);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(28, \"ion-fab-button\", 10);\n        i0.ɵɵlistener(\"click\", function AdvancedPage_Template_ion_fab_button_click_28_listener() {\n          return ctx.onClickDestroyLocations();\n        });\n        i0.ɵɵelement(29, \"ion-spinner\", 15)(30, \"ion-icon\", 19);\n        i0.ɵɵelementEnd()()();\n        i0.ɵɵelementStart(31, \"div\", 20, 21)(33, \"div\", 22)(34, \"div\", 23)(35, \"p\")(36, \"strong\");\n        i0.ɵɵtext(37, \"Failed to load Google Maps SDK\");\n        i0.ɵɵelementEnd()();\n        i0.ɵɵelementStart(38, \"p\");\n        i0.ɵɵtext(39, \"Do you have an internet connection?\");\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(40, \"pre\")(41, \"code\", 24);\n        i0.ɵɵtext(42);\n        i0.ɵɵelementEnd()()()()()();\n        i0.ɵɵelementStart(43, \"ion-footer\")(44, \"ion-toolbar\", 25)(45, \"ion-buttons\", 2)(46, \"ion-button\", 26);\n        i0.ɵɵlistener(\"click\", function AdvancedPage_Template_ion_button_click_46_listener() {\n          return ctx.onClickGetCurrentPosition();\n        });\n        i0.ɵɵelement(47, \"ion-icon\", 27);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(48, \"ion-button\", 28);\n        i0.ɵɵlistener(\"click\", function AdvancedPage_Template_ion_button_click_48_listener() {\n          return ctx.onClickTestMode();\n        });\n        i0.ɵɵelement(49, \"ion-icon\", 29)(50, \"ion-icon\", 29)(51, \"ion-icon\", 30);\n        i0.ɵɵelementEnd()();\n        i0.ɵɵelementStart(52, \"ion-title\")(53, \"span\", 31);\n        i0.ɵɵtext(54, \"Activity\");\n        i0.ɵɵelementEnd();\n        i0.ɵɵtext(55, \"\\u00A0 \");\n        i0.ɵɵelement(56, \"ion-icon\", 32);\n        i0.ɵɵtext(57, \"\\u00A0 \");\n        i0.ɵɵelementStart(58, \"span\", 33);\n        i0.ɵɵtext(59);\n        i0.ɵɵelementEnd()();\n        i0.ɵɵelementStart(60, \"ion-buttons\", 5)(61, \"ion-button\", 34);\n        i0.ɵɵlistener(\"click\", function AdvancedPage_Template_ion_button_click_61_listener() {\n          return ctx.onClickChangePace();\n        });\n        i0.ɵɵelement(62, \"ion-spinner\", 35)(63, \"ion-icon\", 36);\n        i0.ɵɵelementEnd()()()();\n      }\n      if (rf & 2) {\n        i0.ɵɵadvance(8);\n        i0.ɵɵproperty(\"ngModel\", ctx.state.enabled);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngStyle\", i0.ɵɵpureFunction2(25, _c1, ctx.state.containerBorder, ctx.state.containerBorder));\n        i0.ɵɵadvance(11);\n        i0.ɵɵproperty(\"hidden\", !ctx.isResettingOdometer);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"hidden\", ctx.isResettingOdometer);\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"hidden\", !ctx.isEmailingLog);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"hidden\", ctx.isEmailingLog);\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"hidden\", !ctx.isSyncing);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"hidden\", ctx.isSyncing);\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"hidden\", !ctx.isDestroyingLocations);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"hidden\", ctx.isDestroyingLocations);\n        i0.ɵɵadvance(3);\n        i0.ɵɵproperty(\"hidden\", ctx.isGoogleMapsSdkLoaded);\n        i0.ɵɵadvance(9);\n        i0.ɵɵtextInterpolate(ctx.state.locationJson);\n        i0.ɵɵadvance(7);\n        i0.ɵɵpropertyInterpolate(\"name\", ctx.iconMap.provider_gps);\n        i0.ɵɵproperty(\"hidden\", !ctx.state.provider.gps);\n        i0.ɵɵadvance(1);\n        i0.ɵɵpropertyInterpolate(\"name\", ctx.iconMap.provider_network);\n        i0.ɵɵproperty(\"hidden\", !ctx.state.provider.network);\n        i0.ɵɵadvance(1);\n        i0.ɵɵpropertyInterpolate(\"name\", ctx.iconMap.provider_disabled);\n        i0.ɵɵproperty(\"hidden\", ctx.state.provider.enabled);\n        i0.ɵɵadvance(5);\n        i0.ɵɵpropertyInterpolate(\"name\", ctx.state.activityIcon);\n        i0.ɵɵadvance(3);\n        i0.ɵɵtextInterpolate1(\"\", ctx.state.odometer, \"km\");\n        i0.ɵɵadvance(2);\n        i0.ɵɵpropertyInterpolate(\"color\", ctx.state.isMoving ? \"danger\" : \"success\");\n        i0.ɵɵproperty(\"disabled\", !ctx.state.enabled);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"hidden\", !ctx.state.isChangingPace);\n        i0.ɵɵadvance(1);\n        i0.ɵɵpropertyInterpolate(\"name\", ctx.state.isMoving ? \"pause\" : \"play\");\n        i0.ɵɵproperty(\"hidden\", ctx.state.isChangingPace);\n      }\n    },\n    dependencies: [i5.NgStyle, i6.NgControlStatus, i6.NgModel, i1.IonButton, i1.IonButtons, i1.IonContent, i1.IonFab, i1.IonFabButton, i1.IonFabList, i1.IonFooter, i1.IonHeader, i1.IonIcon, i1.IonSpinner, i1.IonTitle, i1.IonToggle, i1.IonToolbar, i1.BooleanValueAccessor]\n  });\n  return AdvancedPage;\n})();\nexport { AdvancedPage };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}